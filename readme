================================================================================
BROWSER AUTOMATION APP WITH GEMINI API - COMPLETE EXPLANATION
================================================================================

PROJECT: automation-app
PURPOSE: Generate and execute Playwright automation scripts using AI (Gemini API)
STACK: Node.js + Express + Playwright + Gemini API

================================================================================
FOLDER STRUCTURE
================================================================================

automation-app/
├── server.js                    → Main Express server (port 3000)
├── package.json                 → Dependencies & project metadata
├── public/                      → Frontend files (what users see)
│   ├── index.html               → User interface form
│   ├── style.css                → Styling & layout
│   └── script.js                → Frontend logic (button clicks, file uploads)
├── routes/                      → API endpoints
│   └── automation.js            → Routes: /api/generate, /api/run
├── utils/                       → Backend helper functions
│   ├── ollama.js                → Connects to Gemini API for script generation
│   └── playwright-runner.js     → Executes automation scripts
├── uploads/                     → Temporary file storage
└── .env (optional)              → Store API keys securely

================================================================================
HOW EACH FILE WORKS
================================================================================

1. SERVER.JS
   Purpose: Main entry point - starts the Express server
   What it does:
   - Listens on port 3000
   - Serves static files (HTML, CSS, JS)
   - Routes requests to /routes/automation.js
   - Handles CORS (allows frontend to talk to backend)
   
   Key lines:
   app.listen(3000) → Server starts
   app.use(express.static('public')) → Serves frontend files
   app.use('/api', automationRoutes) → Routes all /api/* requests

2. PACKAGE.JSON
   Purpose: Project configuration
   What it does:
   - Lists all dependencies (express, playwright, axios, multer, etc.)
   - Defines npm scripts (npm start, npm dev)
   - Specifies Node.js versions
   
   Dependencies:
   - express: Web server framework
   - playwright: Browser automation library
   - axios: HTTP client for API calls
   - multer: Handle file uploads
   - cors: Allow cross-origin requests

3. PUBLIC/INDEX.HTML
   Purpose: User interface
   What it does:
   - Displays form for user input
   - Shows file upload fields
   - Shows textarea for automation request
   - Displays generated script
   - Has buttons: Generate, Run, Edit
   
   Sections:
   - Knowledge Base Upload: Upload docs/guides
   - Context Upload: Upload images/configs
   - Automation Request: What to automate
   - Generated Script: Shows AI-generated code
   - Results: Shows success/error

4. PUBLIC/STYLE.CSS
   Purpose: Make the interface look good
   What it does:
   - Purple gradient background
   - Form styling
   - Button hover effects
   - File list styling
   - Responsive layout
   
   Key features:
   - Dark code editor look for script display
   - Color-coded messages (green=success, red=error)
   - File upload dashed border styling

5. PUBLIC/SCRIPT.JS
   Purpose: Frontend logic (browser-side JavaScript)
   What it does:
   - Listens for button clicks
   - Handles file uploads
   - Sends data to backend API
   - Displays responses
   - Allows editing scripts
   
   Key functions:
   - handleFileUpload(): Stores selected files
   - generateScript(): Sends request to /api/generate
   - runScript(): Sends request to /api/run
   - toggleEditMode(): Allows editing generated scripts

6. ROUTES/AUTOMATION.JS
   Purpose: API endpoints
   What it does:
   - Receives requests from frontend
   - Processes file uploads
   - Calls utils/ollama.js to generate scripts
   - Calls utils/playwright-runner.js to execute scripts
   - Returns results to frontend
   
   Endpoints:
   POST /api/generate
   ├─ Receives: userRequest, context files, knowledge files
   ├─ Processes: Reads all files
   ├─ Calls: generateScript() from ollama.js
   └─ Returns: Generated Playwright script
   
   POST /api/run
   ├─ Receives: Playwright script code
   ├─ Calls: runAutomation() from playwright-runner.js
   └─ Returns: Execution results + console logs

7. UTILS/OLLAMA.JS
   Purpose: AI script generation
   What it does:
   - Builds a detailed prompt with:
     * User request
     * Knowledge base (uploaded files)
     * Context requirements
   - Sends prompt to Gemini API
   - Cleans up response (removes markdown)
   - Returns clean JavaScript code
   
   Process:
   1. Receives: userRequest, context, knowledgeBase
   2. Combines into a system prompt
   3. Sends to Gemini API via HTTPS
   4. Receives generated code
   5. Removes markdown formatting
   6. Returns clean code
   
   API Call:
   POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent
   Body: { contents: [{ parts: [{ text: prompt }] }] }

8. UTILS/PLAYWRIGHT-RUNNER.JS
   Purpose: Execute automation scripts
   What it does:
   - Launches Chromium browser (visible window)
   - Creates a page object
   - Executes generated script
   - Captures all console logs
   - Captures any errors
   - Returns results
   
   Process:
   1. Launch browser: chromium.launch({ headless: false })
   2. Create page: await context.newPage()
   3. Execute script: new Function(...script...)()
   4. Listen for logs: page.on('console', ...)
   5. Listen for errors: page.on('pageerror', ...)
   6. Close browser: await browser.close()
   7. Return output + success/error status

================================================================================
COMPLETE DATA FLOW (STEP BY STEP)
================================================================================

STEP 1: USER OPENS APP
   → Browser navigates to http://localhost:3000
   → server.js serves public/index.html
   → User sees form with upload fields and text areas

STEP 2: USER FILLS FORM
   → User uploads knowledge base files (optional)
   → User uploads context files (optional)
   → User types automation request (REQUIRED)
   → Example request: "Open Google, search for Playwright, click first result"

STEP 3: USER CLICKS "GENERATE SCRIPT"
   → public/script.js captures form data
   → Creates FormData object with files + text
   → Sends HTTP POST to /api/generate
   
   Request body:
   {
     knowledgeFiles: [file1, file2, ...]
     contextFiles: [file3, file4, ...]
     userRequest: "User's automation request"
     contextText: "Custom requirements"
   }

STEP 4: BACKEND RECEIVES REQUEST
   → routes/automation.js receives POST /api/generate
   → multer middleware extracts files
   → Reads file contents from disk
   → Builds combined knowledge base string
   → Calls generateScript(userRequest, context, knowledgeBase)

STEP 5: GEMINI API GENERATES SCRIPT
   → ollama.js builds detailed prompt:
   
   Prompt structure:
   ┌────────────────────────────────────────┐
   │ "You are Playwright expert. Generate   │
   │ script for: {userRequest}              │
   │                                        │
   │ CONTEXT:                               │
   │ {contextText}                          │
   │                                        │
   │ KNOWLEDGE BASE:                        │
   │ {knowledgeBase}                        │
   │                                        │
   │ Return ONLY JavaScript code."          │
   └────────────────────────────────────────┘
   
   → Sends to Gemini API via HTTPS
   → Gemini AI thinks and generates script
   → Returns: "const { chromium }..."
   → ollama.js cleans up markdown
   → Returns clean code to routes/automation.js

STEP 6: BACKEND RETURNS SCRIPT
   → routes/automation.js receives response from Gemini
   → Sends HTTP response to frontend:
   
   Response:
   {
     script: "const { chromium } = require('playwright'); ...",
     success: true
   }

STEP 7: FRONTEND DISPLAYS SCRIPT
   → public/script.js receives response
   → Displays script in textarea
   → Enables "Run Automation" button
   → User can edit script if needed
   → Shows "✅ Script generated successfully!"

STEP 8: USER REVIEWS & CLICKS "RUN AUTOMATION"
   → User can:
     * Review the generated script
     * Edit it with "Edit Script" button
     * Run as-is
   → Clicks "▶️ Run Automation"
   → public/script.js sends HTTP POST to /api/run
   
   Request body:
   {
     script: "const { chromium }..."  // The actual code to run
   }

STEP 9: BACKEND EXECUTES SCRIPT
   → routes/automation.js receives POST /api/run
   → Calls runAutomation(script) from playwright-runner.js
   → playwright-runner.js:
     * Launches Chrome (visible, headless: false)
     * Creates browser + page objects
     * Executes the script code
     * Script performs actions:
       - Navigate to URL
       - Fill forms
       - Click buttons
       - Extract text
       - Take screenshots
       - etc.
     * Captures console logs
     * Captures errors
     * Closes browser
     * Returns results

STEP 10: BROWSER OPENS & AUTOMATION RUNS
   → User sees browser window open
   → Script executes line by line
   → Browser performs all actions
   → User can watch in real-time (headless: false)

STEP 11: RESULTS RETURNED
   → playwright-runner.js sends results:
   
   Response:
   {
     success: true,
     message: "Automation completed successfully",
     output: "[LOG] Navigation complete\n[LOG] Form filled\n..."
   }

STEP 12: FRONTEND DISPLAYS RESULTS
   → public/script.js receives response
   → Shows success message in green
   → Displays all console logs
   → Shows any errors in red
   → User can see what happened

================================================================================
EXAMPLE WORKFLOW
================================================================================

SCENARIO: User wants to automate Gmail login

1. User uploads: gmail_password.txt (context)
2. User enters request: "Login to Gmail with test@gmail.com"
3. Clicks "Generate Script"
4. System sends request + knowledge to Gemini
5. Gemini returns:
   
   const { chromium } = require('playwright');
   
   (async () => {
     const browser = await chromium.launch({ headless: false });
     const page = await browser.newPage();
     
     await page.goto('https://mail.google.com');
     await page.fill('[name="identifier"]', 'test@gmail.com');
     await page.click('text=Next');
     await page.waitForLoadState('networkidle');
     console.log('✅ Gmail login page loaded');
     
     // ... more steps
   })();

6. User clicks "Run"
7. Browser opens, script executes:
   ├─ Navigates to Gmail
   ├─ Enters email
   ├─ Clicks Next
   ├─ Waits for page
   └─ Logs success
8. Results show: ✅ Automation completed, ✅ Gmail login page loaded

================================================================================
KEY CONCEPTS
================================================================================

HEADLESS MODE:
- headless: true = Browser runs invisible (fast, no visual feedback)
- headless: false = Browser window visible (slow, can see actions)
- App uses headless: false for testing/learning

LOCATOR STRATEGIES (Priority):
1. getByRole() - Most reliable (uses accessibility)
2. getByLabel() - Form labels
3. getByPlaceholder() - Input placeholders
4. getByText() - Visible text
5. CSS Selectors - ID, class, attribute
6. XPath - Last resort

WAITS:
- waitForLoadState('networkidle') - Wait for network idle
- waitForSelector() - Wait for element to appear
- waitForURL() - Wait for URL change
- page.click(), page.fill() - Auto-wait

ERROR HANDLING:
- Try-catch blocks catch failures
- Multiple retry attempts
- Fallback locators
- Clear error messages

================================================================================
SETUP INSTRUCTIONS
================================================================================

1. Create folder:
   mkdir automation-app
   cd automation-app

2. Create subfolders:
   mkdir public routes utils uploads

3. Copy all files:
   - server.js → root
   - package.json → root
   - public/* → public/
   - routes/* → routes/
   - utils/* → utils/

4. Install dependencies:
   npm install

5. Set Gemini API key in utils/ollama.js:
   const GEMINI_API_KEY = 'your_api_key_here'

6. Start server:
   npm start

7. Open browser:
   http://localhost:3000

================================================================================
TROUBLESHOOTING
================================================================================

ERROR: "Gemini API error: models/gemini-pro is not found"
FIX: Change model name to 'gemini-2.0-flash' in utils/ollama.js

ERROR: "Port 3000 already in use"
FIX: Change port in server.js or kill process using port

ERROR: "File upload not working"
FIX: Make sure uploads/ folder exists

ERROR: "Script runs but doesn't click anything"
FIX: Check locator in generated script, use browser DevTools to inspect

ERROR: "Browser doesn't open"
FIX: Check if headless: false is set in playwright-runner.js

================================================================================
FEATURES
================================================================================

✅ Upload knowledge base (docs, guides)
✅ Upload context (screenshots, configs)
✅ Custom automation requests in plain English
✅ AI generates Playwright scripts
✅ Edit generated scripts
✅ Run scripts with visible browser
✅ Capture console logs
✅ Capture errors
✅ Show success/failure clearly
✅ File cleanup after processing

================================================================================
SECURITY NOTES
================================================================================

⚠️ WARNING: API key is hardcoded in utils/ollama.js
   - NEVER push this to GitHub
   - Use environment variables in production
   - Use .env file for local development

⚠️ Generated scripts execute with full browser permissions
   - Could access sensitive data
   - Could click on malicious links
   - Review scripts before running

⚠️ Uploaded files are temporarily stored
   - Deleted after processing
   - Still vulnerable during processing
   - Use private/secure connection

================================================================================
FUTURE IMPROVEMENTS
================================================================================

1. Add environment variables for API key (.env)
2. Add database to store automation history
3. Add scheduled automation (cron jobs)
4. Add retry logic with exponential backoff
5. Add proxy support for IP rotation
6. Add screenshot/video recording
7. Add data extraction and export (CSV, JSON)
8. Add webhook support for notifications
9. Add authentication for multi-user
10. Add Docker containerization

================================================================================
END OF DOCUMENTATION
================================================================================